<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This is the GNU Emacs Lisp Reference Manual
corresponding to Emacs version 27.2.

Copyright (C) 1990-1996, 1998-2021 Free Software Foundation,
Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License," with the
Front-Cover Texts being "A GNU Manual," and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rev="made" href="mailto:bug-gnu-emacs@gnu.org">
<link rel="icon" type="image/png" href="/graphics/gnu-head-mini.png">
<meta name="ICBM" content="42.256233,-71.006581">
<meta name="DC.title" content="gnu.org">

<style type="text/css">
@import url('/software/emacs/manual.css');
</style>
</head>

<body lang="en">
<span id="The-Zen-of-Buffer-Display"></span><div class="header" style="background-color:#DDDDFF">
<p>
Previous: <a href="Precedence-of-Action-Functions.html" accesskey="p" rel="prev">Precedence of Action Functions</a>, Up: <a href="Displaying-Buffers.html" accesskey="u" rel="up">Displaying Buffers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>

<span id="The-Zen-of-Buffer-Display-1"></span><h4 class="subsection">28.13.6 The Zen of Buffer Display</h4>
<span id="index-guidelines-for-buffer-display"></span>
<span id="index-writing-buffer-display-actions"></span>
<span id="index-buffer-display-conventions"></span>

<p>In its most simplistic form, a frame accommodates always one single
window that can be used for displaying a buffer.  As a consequence, it
is always the latest call of <code>display-buffer</code> that will have
succeeded in placing its buffer there.
</p>
<p>Since working with such a frame is not very practical, Emacs by
default allows for more complex frame layouts controlled by the
default values of the frame size and the <code>split-height-threshold</code>
and <code>split-width-threshold</code> options.  Displaying a buffer not yet
shown on a frame then either splits the single window on that frame or
(re-)uses one of its two windows.
</p>
<p>The default behavior is abandoned as soon as the user customizes
one of these thresholds or manually changes the frame&rsquo;s layout.  The
default behavior is also abandoned when calling <code>display-buffer</code>
with a non-<code>nil</code> <var>action</var> argument or the user customizes one
of the options mentioned in the previous subsections.  Mastering
<code>display-buffer</code> soon may become a frustrating experience due to
the plethora of applicable display actions and the resulting frame
layouts.
</p>
<p>However, refraining from using buffer display functions and falling
back on a split &amp; delete windows metaphor is not a good idea either.
Buffer display functions give Lisp programs and users a framework to
reconcile their different needs; no comparable framework exists for
splitting and deleting windows.  Buffer display functions also allow
to at least partially restore the layout of a frame when removing a
buffer from it later (see <a href="Quitting-Windows.html">Quitting Windows</a>).
</p>
<p>Below we will give a number of guidelines to redeem the frustration
mentioned above and thus to avoid literally losing buffers in-between
the windows of a frame.
</p>
<dl compact="compact">
<dt>Write display actions without stress</dt>
<dd><p>Writing display actions can be a pain because one has to lump together
action functions and action alists in one huge list.  (Historical
reasons prevented us from having <code>display-buffer</code> support
separate arguments for these.)  It might help to memorize some basic
forms like the ones listed below:
</p>
<div class="example">
<pre class="example">'(nil (inhibit-same-window . t))
</pre></div>

<p>specifies an action alist entry only and no action function.  Its sole
purpose is to inhibit a <code>display-buffer-same-window</code> function
specified elsewhere from showing the buffer in the same window, see
also the last example of the preceding subsection.
</p>
<div class="example">
<pre class="example">'(display-buffer-below-selected)
</pre></div>

<p>on the other hand, specifies one action function and an empty action
alist.  To combine the effects of the above two specifications one
would write the form
</p>
<div class="example">
<pre class="example">'(display-buffer-below-selected (inhibit-same-window . t))
</pre></div>

<p>to add another action function one would write
</p>
<div class="example">
<pre class="example">'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t))
</pre></div>

<p>and to add another alist entry one would write
</p>
<div class="example">
<pre class="example">'((display-buffer-below-selected display-buffer-at-bottom)
  (inhibit-same-window . t)
  (window-height . fit-window-to-buffer))
</pre></div>

<p>That last form can be used as <var>action</var> argument of
<code>display-buffer</code> in the following way:
</p>
<div class="example">
<pre class="example">(display-buffer
 (get-buffer-create &quot;*foo*&quot;)
 '((display-buffer-below-selected display-buffer-at-bottom)
   (inhibit-same-window . t)
   (window-height . fit-window-to-buffer)))
</pre></div>

<p>In a customization of <code>display-buffer-alist</code> it would be used as
follows:
</p>
<div class="example">
<pre class="example">(customize-set-variable
 'display-buffer-alist
 '((&quot;\\*foo\\*&quot;
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))))
</pre></div>

<p>To add a customization for a second buffer one would then write:
</p>
<div class="example">
<pre class="example">(customize-set-variable
 'display-buffer-alist
 '((&quot;\\*foo\\*&quot;
    (display-buffer-below-selected display-buffer-at-bottom)
    (inhibit-same-window . t)
    (window-height . fit-window-to-buffer))
   (&quot;\\*bar\\*&quot;
    (display-buffer-reuse-window display-buffer-pop-up-frame)
    (reusable-frames . visible))))
</pre></div>

</dd>
<dt>Treat each other with respect</dt>
<dd><p><code>display-buffer-alist</code> and <code>display-buffer-base-action</code> are
user options&mdash;Lisp programs must never set or rebind them.
<code>display-buffer-overriding-action</code>, on the other hand, is
reserved for applications&mdash;who seldom use that option and if they use
it, then with utmost care.
</p>
<p>Older implementations of <code>display-buffer</code> frequently caused
users and applications to fight over the settings of user options like
<code>pop-up-frames</code> and <code>pop-up-windows</code> (see <a href="Choosing-Window-Options.html">Choosing Window Options</a>).  This was one major reason for redesigning
<code>display-buffer</code>&mdash;to provide a clear framework specifying what
users and applications should be allowed to do.
</p>
<p>Lisp programs must be prepared that user customizations may
cause buffers to get displayed in an unexpected way.  They should
never assume in their subsequent behavior, that the buffer has been
shown precisely the way they asked for in the <var>action</var> argument of
<code>display-buffer</code>.
</p>
<p>Users should not pose too many and too severe restrictions on how
arbitrary buffers get displayed.  Otherwise, they will risk to lose
the characteristics of showing a buffer for a certain purpose.
Suppose a Lisp program has been written to compare different versions
of a buffer in two windows side-by-side.  If the customization of
<code>display-buffer-alist</code> prescribes that any such buffer should be
always shown in or below the selected window, the program will have a
hard time to set up the desired window configuration via
<code>display-buffer</code>.
</p>
<p>To specify a preference for showing an arbitrary buffer, users
should customize <code>display-buffer-base-action</code>.  An example of how
users who prefer working with multiple frames would do that was given
in the previous subsection.  <code>display-buffer-alist</code> should be
reserved for displaying specific buffers in a specific way.
</p>
</dd>
<dt>Consider reusing a window that already shows the buffer</dt>
<dd><p>Generally, it&rsquo;s always a good idea for users and Lisp
programmers to be prepared for the case that a window already shows
the buffer in question and to reuse that window.  In the preceding
subsection we have shown that failing to do so properly may cause
<code>display-buffer</code> to continuously pop up a new frame although a
frame showing that buffer existed already.  In a few cases only, it
might be undesirable to reuse a window, for example, when a different
portion of the buffer should be shown in that window.
</p>
<p>Hence, <code>display-buffer-reuse-window</code> is one action function
that should be used as often as possible, both in <var>action</var>
arguments and customizations.  An <code>inhibit-same-window</code> entry in
the <var>action</var> argument usually takes care of the most common case
where reusing a window showing the buffer should be avoided&mdash;that
where the window in question is the selected one.
</p>
</dd>
<dt>Attract focus to the window chosen</dt>
<dd><p>This is a no-brainer for people working with multiple frames&mdash;the
frame showing the buffer will automatically raise and get focus unless
an <code>inhibit-switch-frame</code> entry forbids it.  For single frame
users this task can be considerably more difficult.  In particular,
<code>display-buffer-pop-up-window</code> and
<code>display-buffer-use-some-window</code> can become obtrusive in this
regard.  They split or use a seemingly arbitrary (often the largest or
least recently used) window, distracting the user&rsquo;s attention.
</p>
<p>Some Lisp programs therefore try to choose a window at the bottom of
the frame, for example, in order to display the buffer in vicinity of
the minibuffer window where the user is expected to answer a question
related to the new window.  For non-input related actions
<code>display-buffer-below-selected</code> might be preferable because the
selected window usually already has the user&rsquo;s attention.
</p>
</dd>
<dt>Handle subsequent invocations of <code>display-buffer</code></dt>
<dd><p><code>display-buffer</code> is not overly well suited for displaying several
buffers in sequence and making sure that all these buffers are shown
orderly in the resulting window configuration.  Again, the standard
action functions <code>display-buffer-pop-up-window</code> and
<code>display-buffer-use-some-window</code> are not very suited for this
purpose due to their somewhat chaotic nature in more complex
configurations.
</p>
<p>To produce a window configuration displaying multiple buffers (or
different views of one and the same buffer) in one and the same
display cycle, Lisp programmers will unavoidably have to write
their own action functions.  A few tricks listed below might help in
this regard.
</p>
<ul>
<li> Making windows atomic (see <a href="Atomic-Windows.html">Atomic Windows</a>) avoids breaking an
existing window composition when popping up a new window.
The new window will pop up outside the composition instead.

</li><li> Temporarily dedicating windows to their buffers (see <a href="Dedicated-Windows.html">Dedicated Windows</a>) avoids using a window for displaying a different
buffer.  A non-dedicated window will be used instead.

</li><li> Calling <code>window-preserve-size</code> (see <a href="Preserving-Window-Sizes.html">Preserving Window Sizes</a>)
will try to keep the size of the argument window unchanged when
popping up a new window.  You have to make sure that another window in
the same combination can be shrunk instead, though.

</li><li> Side windows (see <a href="Side-Windows.html">Side Windows</a>) can be used for displaying
specific buffers always in a window at the same position of a frame.
This permits grouping buffers that do not compete for being shown at
the same time on a frame and showing any such buffer in the same window
without disrupting the display of other buffers.

</li><li> Child frames (see <a href="Child-Frames.html">Child Frames</a>) can be used to display a buffer
within the screen estate of the selected frame without disrupting that
frame&rsquo;s window configuration and without the overhead associated with
full-fledged frames as inflicted by <code>display-buffer-pop-up-frame</code>.
</li></ul>
</dd>
</dl>



<div class="header" style="background-color:#DDDDFF">
<p>
Previous: <a href="Precedence-of-Action-Functions.html" accesskey="p" rel="prev">Precedence of Action Functions</a>, Up: <a href="Displaying-Buffers.html" accesskey="u" rel="up">Displaying Buffers</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
